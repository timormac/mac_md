# 技术积累

#### 布隆过滤器首次问题

```mysql
使用Flink自带的状态管理功能处理首次消费逻辑在某些情况下可能确实效率不高，特别是在用户数量非常広泛且数据流非常大的情况下。在这种情况下，布隆过滤器（Bloom Filter）和Bigtable可能是更好的解决方案。下面是这两种技术的简要介绍以及它们的工作原理。

### 布隆过滤器（Bloom Filter）

布隆过滤器是一种空间效率极高的概率数据结构，用于测试一个元素是否在一个集合中。它的优点是空间和时间效率都非常高，但缺点是有一定的误判率（False Positive）。布隆过滤器不存储元素本身，而是通过多个哈希函数将元素映射到一个位数组中。

工作原理：
1. 初始化时，创建一个位数组和几个哈希函数。
2. 插入元素时，使用每个哈希函数计算元素的哈希值，并将位数组中对应的位置设为1。
3. 查询元素是否存在时，同样计算哈希值，并检查位数组中这些位置是否都是1。如果都是1，可以认为元素可能存在；如果有任何一个不是1，则元素一定不存在。

布隆过滤器适用于首次消费的判断，因为你可以将用户ID添加到布隆过滤器中，当检查一个用户ID时，如果布隆过滤器表示该用户不存在，则可以认为是首次消费。

### Bigtable

Bigtable是Google开发的一种分布式存储系统，用于管理结构化数据，能够扩展到非常大的数据集上。它结合了传统数据库的一些特点和Google文件系统的扩展性。

工作原理：
1. Bigtable使用行键、列键和时间戳作为索引，存储单元格数据。
2. 数据以稀疏、多维的排序映射表的形式存储，可以进行快速查找和高效扩展。
3. Bigtable通过自动分割表来实现数据的分布式存储，每个表可以分布在多个服务器上。

在处理首次消费的判断时，可以使用Bigtable来存储每个用户的消费记录。每次用户消费时，可以快速查询Bigtable来确定是否已有记录。

### 整合布隆过滤器和Bigtable

在Flink中，你可以结合使用布隆过滤器和Bigtable来提高效率：
1. 使用布隆过滤器作为快速检查步骤，判断用户是否可能已经消费过。
2. 如果布隆过滤器表明用户可能消费过，再查询Bigtable以确认是否真的有消费记录。
3. 如果布隆过滤器表明用户没有消费过，可以认为是首次消费，然后更新Bigtable和布隆过滤器。

这种方法的好处是布隆过滤器可以大幅减少对Bigtable的查询次数，因为只有当布隆过滤器认为用户可能已经消费过时，才需要查询Bigtable。这样既利用了布隆过滤器的高效性，也保证了通过Bigtable的准确性，适合处理大规模数据流场景。
```





# 面试记录

#### 特斯拉面试

```mysql
#是否首充(布隆过滤器)
一个实时充电记录流,记录一个永久的状态哪些人充过电。永久状态，还不太大,不接入外界系统。flink内部的bigtable和布隆过滤器

#spark中
df1
df1.cache()
df2 = df1.map()
df3 = df1.map()
df1.uncache()

df2.sink()
df1.sink()
这里的问题就是在行动算子执行前,df1就取消缓存了，df1的cache不生效，真正执行map是在行动算子触发
ßß

#flink
一个流中，某条数据，记录开始时间充电。后序会更新是否有效。通key的2条数据,超过3分钟，任务这个key失效。
开一个3分钟的窗口,窗口能判断是否,设置ttl




```



