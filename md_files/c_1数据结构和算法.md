# 视频进度

p9

# 简介

算法优化顶级案例

bilibili 视频中，求x的开平方，就是利用小数在计算机底层的存储方式，结合对数,以及牛顿速算法的思路，快速求x的开方

已经x/2  根据小数的存储方式直接左移一个二进制即可



# 优化案例

### 顶级案例开根号

算法优化顶级案例

bilibili 视频中，求x的开平方，就是利用小数在计算机底层的存储方式，结合对数,以及牛顿速算法的思路，快速求x的开方

已经x/2  根据小数的存储方式直接左移一个二进制即可



# 问题待解决

### 二叉树插入问题

二叉树，如果是id自增从0-100，那么都是右子节点，就是个单链表了，只有id不是自增的，才能保证插入的不是单右路线



# 问题待回顾





# 基本概念

### 时间复杂度

冒泡排序需要便利   n平方/2 次

快排需要   n*log2^n次  

### 空间复杂度

### 数据结构背景

```mysql
数据结构是计算机科学中用于组织和存储数据的方式。它们提供了一种管理和操作数据的方法，以便有效地访问和修改数据。数据结构在计算机科学中起着至关重要的作用，它们的选择和设计直接影响到算法的效率和性能。

以下是几种常见的数据结构及其出现背景：

#数组（Array）：
数组是一种线性数据结构，用于存储具有相同数据类型的元素序列。数组的出现背景可以追溯到早期的计算机系统，它们提供了一种连续存储和随机访问元素的方式。数组的主要优点是访问元素的速度快，但插入和删除操作较慢。
当你的数据是有序的,当你要中间插入或者删除某个数时，需要整体将插入坐标的数据，前移或者后移

2. 链表（Linked List）：链表是一种线性数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针。链表的出现背景是为了解决数组插入和删除操作效率低的问题。链表的主要优点是插入和删除操作的效率高，但访问元素需要遍历链表。

3. 栈（Stack）：栈是一种后进先出（LIFO）的数据结构，只允许在栈顶进行插入和删除操作。栈的出现背景是为了支持函数调用和递归等应用场景。栈的主要优点是操作简单高效，但只能访问栈顶元素。

4. 队列（Queue）：队列是一种先进先出（FIFO）的数据结构，允许在队尾插入元素，在队头删除元素。队列的出现背景是为了模拟现实生活中的排队场景，例如任务调度和消息传递等。队列的主要优点是操作简单高效，但只能访问队头和队尾元素。

5. 树（Tree）：树是一种非线性数据结构，由节点和边组成。树的出现背景是为了模拟现实生活中的层次关系，例如文件系统和组织结构等。树的主要优点是可以高效地进行搜索和插入操作，常见的树结构包括二叉树、红黑树和AVL树等。

6. 图（Graph）：图是一种非线性数据结构，由节点和边组成，节点之间的关系可以是任意的。图的出现背景是为了解决实际问题中的网络关系和路径搜索等。图的主要优点是能够表示复杂的关系和连接，但操作复杂度较高。

这些数据结构都有各自的特点和适用场景，选择合适的数据结构可以提高算法的效率和性能。在实际应用中，还可以通过组合和扩展这些基本数据结构来构建更复杂的数据结构和算法。
```





# 算法理解

```sql
算法这东西，多想想生活，就简单了。

插入排序就是扑克牌排序

冒泡可能保证任何数据不规则都能n平方完成

快排就是无限2分法，目前问题就是中点值如何取最合理。模拟场景:2分法就像我们平时的翻书500页找333页

哈西算法，我猜测类似，随便一条曲线能求出函数值，那么1000个定点，能找到个哈西算法，能直接算出数据。
哈西算法，当数集很大时，算法本身也是个很复杂的东西，也不值得
哈西算法，一个提供公式，一个提供x合集，才能拿到所有的y。这个就是哈西加密把。

```





# 排序算法



### 冒泡排序

应用场景:不知道数据分布情况

优点：不管数据怎么个分布都能按固定次数排序完成

按顺序从头遍历到最后，每次交换最大值向右移,遍历次数是 100 99 98 ->1 



### 快排排序

快排就是2分法

快排是最大值的对数级别，而不是数字个数的对数级别。如果我取1到100的十亿倍，就会降低很多效率

快排的核心问题是，怎么拿到中间数，才能让数分开到两边



实际例子:

给全校500人语文成绩排序,已知0-100分，集中分布在40-90分，其他分布很少。

具体操作50以下去左边，50以上去右边。然后0-25再左，25-50再右，以此类推，知道数据集合<=1即排序完成。

这里有优化就是第一个中点取65分最合适。

```
选择排序和快速排序是两种不同的排序算法，它们的效率差异主要在于比较和交换的次数。

选择排序的工作原理是每次从未排序的部分选出最小（或最大）的元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续这个过程，直到所有元素都被排序。选择排序的时间复杂度是固定的，是n(n-1)/2 是n平方级别

快速排序的工作原理则是通过一个称为“分区”（partition）的过程，选择一个“基准”（pivot）元素，然后将数组分成两个子数组，左边的子数组小于等于基准值，右边的子数组大于等于基准值，然后对这两个子数组进行递归排序。快速排序的平均时间复杂度是 nlogn，但最坏情况下（即每次分区都极不平衡）可以退化到n平方

关键点在于，快速排序的比较和交换次数平均来看是远少于选择排序的。在平均情况下，每一次分区操作都能将数组分成大致相等的两部分，这样每一层递归的总操作次数大约是logn，所以总次数为n*logn。


比如对于100个数的数组：
所以，尽管在最坏情况下快速排序可能并不比选择排序更有效率，但在平均情况下，快速排序通常要快得多。实际上，由于快速排序在实践中的平均性能非常好，它是最常用的排序算法之一。
```





### 插入排序

应用场景:数据均匀分布的情况

优点：最少次数完成排序,最低只要一遍就能

### 归并排序

```mysql
#双指针
双指针比较是一种思维方式，归并排序和快排一样，都是用了双指针。
为什么只有双指针，没有3，4指针，因为指针之间需要比较大小,双指针只需要比较一次，三指针需要比较3次，比较复杂，逻辑不好写。


#归并排序原理


#内存不够用归并来实现排序
假设内存为120bytes，只能存120个数，对1000个数进行排序
步骤1:1000个数,50分一组，分20组，组间区内有序。分20组的方式为，第一次按字节索引，读取文件位置50个，记录索引位置。
步骤2:随意取2组50长度数据，通过双指针，合并成100长度的数据，成为10组100长度数据。
步骤3:取2组100长度数据，注意100长度，每次只能按下标索引取前50个数字，排序生成5组200长度的数据。具体流程是内存到100个数字，溢写磁盘，然后清空内存,通过指针再排序后100长度,然后追加到刚才的文件。








```



### 哈希算法

# 查找算法

### 二分查找

二分查找的前提是数据有序



### 插值查找

二分查找的变种，和开根号案例相同，二分查找每次都是从mid开始比较，如果能直接确定一个合适的middle位置，

那么可以减少很多次数，插值就是确定一个更合理的mid位置的二分法，每次的middle都是递归计算的，并不是只有第一次middle定位。

个人觉得只有在数据增长率很恒定的情况下，插值算法的middle算法定位会非常准，如果是等差数列这种，斜率固定的，基本一步定位。





### 斐波那契查找

也是二分查找的优化，也是middle定位的。不过和插值查找的区别，middle定位是用斐波那契的0.618来定位每次的middle。

没搞懂？真的能提升性能吗？比插值查找的middle算法更优秀吗？

什么情景下斐波那契能更快的定位middle不清楚。

# 数据结构

### 哈希表

数组+链表

数组+二叉树



### 二叉树

```mysql
#误区
二叉树并不是都是一种：例如比根节点大放左边，小放右边，这个是排序二叉树。
排序二叉树适合当数据库索引
赫夫曼树是用来压缩的
堆是用来队列排序的

不同二叉树使用场景不同，因此创建规则也不同


#设计理念
数组优势：可以根据下标直接访问元素，并且当有序数组时，可以用二分查找优化查询。
数组缺点：增删效率低，要移动大量其他元素

链表优势：插入和删除效率很高
链表缺点：查询时只能每个节点去遍历，查询效率低下

因此有了树结构
树优势: 查询是用二分法，查询效率高。插入和删除也是链表的性能。


#基本概念
满二叉树：所有叶子结点都在最后一程，总节点数是2^n-1。满二叉树是最理想的结果，希望数据插入后都是满二叉树的样子
遍历：前序遍历，中序遍历，后序遍历的使用场景和意义？就是sql中的select *
查找:前序查找，中序查找，后序查找


```

### 排序二叉树

就是左子节点比父节点小，右子节点比父节点大，最简单的二分查找

### B树

2-3树，2-3-4树，都是B树的简单实现

2-3树： 父节点存2个数据，子节点有3个分支，比最小的小，比最大的大，在两数中间

2-3树是为了降低排序二叉树的高度，增加效率



### B+树

对于B树，把所有数据存在叶子结点上，对不通叶子结点做索引，索引也是采取b树的格式，

相比b树，实际上就是多了一步索引定位，减少全局搜索，虽然2分查找已经很快了，为了提速再加索引

### 赫夫曼树

赫夫曼树，用最下层节点记录信息，根据路径生成码表，能保证码表之间前缀没有二义性。

左走是0，右走是1



### 图

多对多的解决方案。树只有一个父节点，父节点可以多个子节点，不满足一些多对多的需求 

### 
