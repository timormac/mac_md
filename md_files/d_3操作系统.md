# 课程进度

计算机底层需要看哪些书(优先级高)  :  https://zhuanlan.zhihu.com/p/542488093

相关书籍的网站:https://www.cnblogs.com/cxuanBlog/p/13320810.html



three easy pieces前置资料: 

computer system: a programmer  https://hansimov.gitbook.io/csapp/ch01-a-tour-of-computer-systems

introduction to computing systems from bits and gates to c and beyond ：和上一本csapp差不多，不够更简单一些



看到了7cpu

```

```



#### 4 Process

```mysql
#进程运行状态
进行
就绪
阻塞：当开启IO时，就会阻塞，这段时间cpu执行其他进行，当io准备完毕了，才会编程就绪状态


#上下文切换
对于每个进程，当切换之前会把物理寄存器的数据，放入到内存位置，记录当前进程寄存器的内容，当使用时从内存恢复到物理寄存器中





```





## 二.cpu虚拟化

#### 6 direct excution

```mysql

#进程切换
当一个进程在cpu运行时，那么代表此时操作系统没在运行，那么操作系统怎么来执行管理进程切换呢
进程切换将cpu交给操作系统目前有2种方式：系统调用，时钟切换

```





#### 7 cpu scheduling

```mysql
#FIFO 先进先出策略  first in first out
缺点： a,b任务同时到达。A任务1000s,B任务10s，这种情况先执行A不合适,

#SJF 最短任务优先 shorteset job first
这个策略适用于a,b,c多个任务同时到达下，先执行最小时间任务

#STCF最短完成时间优先 (抢占式)
a任务100s 20s后b任务10s到达，如果不是抢占式，那么先执行a。stcf会将剩余时间比较，来优先执行短的

以上是我们知道任务时长，并且任务只使用cpu，只考虑周转时间，那么stcf是个好策略。

#响应时间
当前操作系统，更在意的指标不是平均周转时间，而是平均响应时间。因此时分系统产生，这样避免了一些情况。
例如a 100s,b 10s ,c 10s 如果按fifo策略，那么c任务到达后，需要等a,b完成，c才响应，开始执行


#摊消成本
假设上吓人切换需要1ms时间，如果你时间片是没1ms切换一次其他程序，那么将浪费50%时间涌入切换，响应时间是1ms,比较短。
如果时间片是100ms执行一次切换，那么是1%时间用于切换，不过响应时间变为100ms，需要权衡

#io时
io时，进程是处于阻塞状态，io时是不使用cpu的，这时候可以用cpu执行其他进程
```



#### 8 多级反馈调度（细节待总结）

```mysql
#规则
规则 1：如果 A 的优先级 > B 的优先级，运行 A（不运行 B）。
 规则 2：如果 A 的优先级 = B 的优先级，轮转运行
 规则 3：工作进入系统时，放在最高优先级（最上层队列）。
 规则 4a：工作用完整个时间片后，降低其优先级（移入下一个队列）。
 规则 4b：如果工作在其时间片以内主动释放 CPU

#交互密集型
更多的是等待IO输入输出，而不是用cpu

#计算密集型
需要很多 CPU 时间、响应时间却不重要的长时间计算密集型工作

#不知道任务时长下，如何分配执行顺序
你大概可以体会到这个算法的一个主要目标：如果不知道工作是短工
作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级。如果确实是短
工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长
工作了。通过这种方式，MLFQ 近似于 SJF。

#IO密集型执行逻辑
根据上述规则 4b，如果进程在时间片用完之前主动放弃 CPU，
则保持它的优先级不变。这条规则的意图很简单：假设交互型工作中有大量的 I/O 操作（比
如等待用户的键盘或鼠标输入），它会在时间片用完之前放弃 CPU。在这种情况下，我们不
想处罚它，只是保持它的优先级不变。
图 8.4 展示了这个运行过程，交互型工作 B（用灰色表示）每执行 1ms 便需要进行 I/O
操作，它与长时间运行的工作 A（用黑色表示）竞争 CPU。MLFQ 算法保持 B 在最高优先
级，因为 B 总是让出 CPU。如果 B 是交互型工作，MLFQ 就进一步实现了它的目标，让交
互型工作快速运行。
#提升优先级等在p5
```



#### 9 比例份额调度

```mysql
#
```

#### 10 多处理器调度

```mysql
#多cpu如何调度
为了理解多处理器调度带来的新问题，必须先知道它与单 CPU 之间的基本区别。区别
的核心在于对硬件缓存（cache）的使用（见图 10.1），以及多处理器之间共享数据的方式。

#缓存
缓存是基于局部性（locality）的概念，局部性有两种，即时间局部性和空间局部性。
时间局部性是指当一个数据被访问后，它很有可能会在不久的将来被再次访问，比如循
环代码中的数据或指令本身。而空间局部性指的是，当程序访问地址为 x 的数据时，很
有可能会紧接着访问 x 周围的数据，比如遍历数组或指令的顺序执行。由于这两种局部
性存在于大多数的程序中，硬件系统可以很好地预测哪些数据可以放入缓存，从而运行
得很好。
```





## 三.内存虚拟化



#### 13抽象地址空间

```mysql



#进程无感知
虚拟内存（VM）系统的一个主要目标是透明（transparency）①。操作系统实现虚拟内
存的方式，应该让运行的程序看不见。因此，程序不应该感知到内存被虚拟化的事实，相
反，程序的行为就好像它拥有自己的私有物理内存。在幕后，操作系统（和硬件）完成了
所有的工作，让不同的工作复用内存，从而实现这个假象。
透明的这种用法有时令人透透。一些学生认为 “变得透明”意味着把所有事情都公之于众。在这里，“变得透明”意味着
相反的情况：操作系统提供的假象不应该被应用程序看破。因此，按照通常的用法，透明系统是一个很难注意到的系统。

因此你通过程序代码，打印的地址，都是操作系统提供的虚拟地址，只有硬件和操作系统才知道物理真实地址

#如何用硬盘来虚拟内存，提高容量的同时，保证进程状态加载速度
虚拟内存的另一个目标是效率（efficiency）。操作系统应该追求虚拟化尽可能高效
（efficient），包括时间上（即不会使程序运行得更慢）和空间上（即不需要太多额外的内存
来支持虚拟化）。在实现高效率虚拟化时，操作系统将不得不依靠硬件支持，包括 TLB 这样
的硬件功能（我们将在适当的时候学习）。

#保护
操作系统应确保进程受到保护（protect），不会受其他进程影响，操作系统本身也不会受进程影响。当一个进程执行加载、存储或指
令提取时，它不应该以任何方式访问或影响任何其他进程或操作系统本身的内存内容（即
在它的地址空间之外的任何内容）。
```



#### 14内存操作API

```mysql
#待回顾
这里有c语言，如何申请堆内存和释放堆内存，以及常见的内存申请释放问题

#内存类型
编译器完成剩下的事情，确保在你进入 func() 函数的时候，在栈上开辟空间。当你从
该函数退出时，编译器释放内存。因此，如果你希望某些信息存在于函数调用之外，建议
不要将它们放在栈上。
就是这种对长期内存的需求，所以我们才需要第二种类型的内存，即所谓的堆（heap）
内存，其中所有的申请和释放操作都由程序员显式地完成。毫无疑问，这是一项非常艰巨
的任务！这确实导致了很多缺陷。

```



#### 15地址转换

```mysql

```



#### 剩下暂时跳过

## 四.并发

#### 26 并发

```mysql
#多线程和进程区别
多线程（multi-threaded）程序,有多个执行点（多个程序计数器，每个都用于取指令和执行）。换一个角度来看，每个线
程类似于独立的进程，只有一点区别：它们共享地址空间，从而能够访问相同的数据。
与进程相比，线程之间的上下文切换有一点主要区别：地址空间保持不变（即不需要切换当前使用的页表）

在多线程的进程中，是每个线程都有一个栈
```



## 五.持久性

#### 36IO设备

```mysql

```





# 计算机概念

#### cpu使用率

```mysql
#问题
为什么cpu不时刻保持100%的使用率，这样不会使任务执行的更快吗？

#gpt解答

CPU使用率是指CPU在某个时间段内执行任务的占用比例。它通常以百分比表示，表示CPU正在执行任务的时间与总时间的比例。

在平时状态下，CPU使用率不会一直保持100%的原因有几个方面：

1. 系统资源分配：操作系统会根据不同的任务和进程的优先级来分配CPU资源。如果有多个任务同时运行，操作系统会根据任务的优先级和调度算法来合理分配CPU时间片。因此，并不是所有任务都需要全速运行，有些任务可能会被暂时挂起或者降低优先级，以便给其他任务更多的执行时间。

2. 等待外部资源：在执行某些任务时，CPU可能需要等待外部资源的输入或输出，比如等待磁盘读写、网络传输等。在这些等待的时间段内，CPU并不会一直处于活动状态，因此CPU使用率会下降。

3. 空闲时间：即使没有任务需要执行，CPU也会处于空闲状态。在这段时间内，CPU使用率为0%。

4. 节能和散热考虑：为了节能和避免过热，现代操作系统和硬件通常会采取措施来降低CPU的工作频率或进入低功耗状态，当系统负载较低或没有任务需要执行时，CPU会进入节能模式。这样可以延长电池寿命，减少能耗，并降低散热需求。

总的来说，CPU使用率不一直保持100%是为了合理分配资源、等待外部资源、节能和散热考虑等方面的原因。在实际应用中，通过合理的任务调度和资源管理，可以最大化地利用CPU的性能，提高任务执行效率。
```



#### IO不使用cpu

```
磁盘I/O（输入/输出）是指计算机系统中的数据传输过程，涉及到将数据从磁盘读取到内存或将数据从内存写入磁盘。虽然磁盘I/O不需要中央处理器（CPU）直接参与数据传输的物理过程，但CPU在磁盘I/O操作中起着重要的作用。

首先，磁盘I/O操作通常需要CPU来发出相应的指令和控制信号。当应用程序请求读取或写入文件时，操作系统会通过CPU将相应的指令发送给磁盘控制器，以便启动磁盘I/O操作。CPU负责管理和协调磁盘I/O请求，确保数据正确地传输到指定的内存位置或从内存写入磁盘。

其次，CPU还负责处理磁盘I/O操作期间可能发生的中断。当磁盘I/O操作完成时，磁盘控制器会向CPU发送中断信号，以通知操作系统数据已经准备好或写入完成。CPU会响应中断，执行相应的中断处理程序，将数据从磁盘传输到内存或执行其他必要的操作。

此外，CPU还负责管理磁盘缓存。磁盘缓存是一块位于内存中的缓冲区，用于存储最近读取或写入的磁盘数据。CPU通过缓存管理机制来提高磁盘I/O的性能。当应用程序请求读取文件时，CPU首先检查缓存中是否存在所需的数据。如果数据已经在缓存中，CPU可以直接从缓存读取数据，而无需进行磁盘访问。如果数据不在缓存中，CPU会触发磁盘I/O操作将数据读取到缓存中，并将数据从缓存传输到应用程序。

综上所述，尽管磁盘I/O操作本身不需要CPU直接参与数据传输的物理过程，但CPU在磁盘I/O操作中扮演着重要的角色，包括发出指令和控制信号、处理中断和管理磁盘缓存等。CPU的参与使得磁盘I/O操作能够在计算机系统中高效地进行。
```

